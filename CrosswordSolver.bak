#lang racket

(define (find-words width length letters)
  (let ((lst (file->lines "linuxwords.txt")))
    (let ((lowerlst (getLower lst)))
      ;I removed all words that wouldn't be looked for (too short, too long,
      ;and words with letters not found in the word search).
      (let ((smallerlst (removeBigSmall lowerlst (max width length))))
        (let ((smallestlst (removeImpossible smallerlst (toOneString letters))))
          ;I first put the letters in a 2D vector in order to easily get their
          ;x and y positions for hashing.
          (let ((letterhash (hashLetters (vectorize letters) width length)))
            (searchPuzzle smallestlst letterhash width length)
          )
        )
      )
    )
  )
)

(define (getLower lst)
  (if (null? lst)
      '()
      (cons (string-downcase (car lst)) (getLower (cdr lst)))
  )
)

(define (removeBigSmall lowerlst maxlength)
  (if (null? lowerlst)
      '()
      (if (and (> (string-length (car lowerlst)) 3)
               (< (string-length (car lowerlst)) (+ maxlength 1))
          )
          (cons (car lowerlst) (removeBigSmall (cdr lowerlst) maxlength))
          (removeBigSmall (cdr lowerlst) maxlength)
      )
  )
)

(define (toOneString letters)
  (string-join letters "")
)

(define (removeImpossible smallerlst letterStr)
  (if (null? smallerlst)
      '()
      (if (possible? (car smallerlst) letterStr 0 1)
          (cons (car smallerlst) (removeImpossible (cdr smallerlst) letterStr))
          (removeImpossible (cdr smallerlst) letterStr)
      )
  )
)

(define (possible? word letterStr start end)
  (if (= (string-length word) start)
      #t
      (if (string-contains? letterStr (substring word start end))
          (possible? word letterStr (+ start 1) (+ end 1))
          #f
      )
  )
)

(define (vectorize letters)
  (list->vector (map list->vector (map string->list letters)))
)

(define (hashLetters letterVector width length)
  (insertLetters (make-hash) letterVector width length 0 0)
)

(define (insertLetters ht letterVector width length y x)
  (cond ((= y width) ht)
        ((= x length) (insertLetters ht letterVector width length (+ y 1) 0))
        (else
         (hash-set! ht (list x y) (vector-ref (vector-ref letterVector y) x))
         (insertLetters ht letterVector width length y (+ x 1))
        )
  )
)

(define (searchPuzzle smallestlst letterhash width length)
  ;This if can easily bailout if the smallestlst starts empty due to no possible words.
  (if (null? smallestlst)
      '()
      (if (checkWord (string->list (car smallestlst)) letterhash width length 0 0)
          (cons (car smallestlst) (searchPuzzle (cdr smallestlst) letterhash width length))
          (searchPuzzle (cdr smallestlst) letterhash width length)
      )
  )
)

(define (checkWord word letterhash width length x y)
  (cond ((= y width) #f)
        ((= x length) (checkWord word letterhash width length 0 (+ y 1)))
        ((equal? (car word) (hash-ref letterhash (list x y)))
         (if (checkNeighbors (cdr word) letterhash width length x y)
             #t
             (checkWord word letterhash width length (+ x 1) y)
         )
        )
        (else (checkWord word letterhash width length (+ x 1) y))
  )
)

(define (checkNeighbors word letterhash width length x y)
  (or (goRight word letterhash width length (+ x 1) y)
      (or (goLeft word letterhash width length (- x 1) y)
          (or (goDown word letterhash width length x (+ y 1))
              (or (goUp word letterhash width length x (- y 1))
                  (or (goLeftDown word letterhash width length (- x 1) (+ y 1))
                      (or (goRightUp word letterhash width length (+ x 1) (- y 1))
                          (or (goRightDown word letterhash width length (+ x 1) (+ y 1))
                              (goLeftUp word letterhash width length (- x 1) (- y 1))
                          )
                      )
                  )
              )
          )
      )
  )
)

(define (goRight word letterhash width length x y)
  (cond ((null? word) #t)
        ((= x length) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goRight (cdr word) letterhash width length (+ x 1) y)
                  #f
              )
        )
  )
)

(define (goLeft word letterhash width length x y)
  (cond ((null? word) #t)
        ((= x -1) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goLeft (cdr word) letterhash width length (- x 1) y)
                  #f
              )
        )
  )
)

(define (goDown word letterhash width length x y)
  (cond ((null? word) #t)
        ((= y width) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goDown (cdr word) letterhash width length x (+ y 1))
                  #f
              )
        )
  )
)

(define (goUp word letterhash width length x y)
  (cond ((null? word) #t)
        ((= y -1) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goUp (cdr word) letterhash width length x (- y 1))
                  #f
              )
        )
  )
)

(define (goLeftDown word letterhash width length x y)
  (cond ((null? word) #t)
        ((or (= y width) (= x -1)) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goLeftDown (cdr word) letterhash width length (- x 1) (+ y 1))
                  #f
              )
        )
  )
)

(define (goRightUp word letterhash width length x y)
  (cond ((null? word) #t)
        ((or (= y -1) (= x length)) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goRightUp (cdr word) letterhash width length (+ x 1) (- y 1))
                  #f
              )
        )
  )
)

(define (goRightDown word letterhash width length x y)
  (cond ((null? word) #t)
        ((or (= y width) (= x length)) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goRightDown (cdr word) letterhash width length (+ x 1) (+ y 1))
                  #f
              )
        )
  )
)

(define (goLeftUp word letterhash width length x y)
  (cond ((null? word) #t)
        ((or (= y -1) (= x -1)) #f)
        (else (if (equal? (car word) (hash-ref letterhash (list x y)))
                  (goLeftUp (cdr word) letterhash width length (- x 1) (- y 1))
                  #f
              )
        )
  )
)

;Test Cases:
;Input:
;(find-words 15 20 '("boarderofcosperdaswr" "allrukidjbqislodasfr" "sdagsimcnxskeowdasdw"
;"egectidoqkmvjfsdasdw" "sxxxkoaicsioaskgbbca" "darknightselfasdfdfk" "boarderofcosperpoiuy"
;"allrukidjbqisloqwert" "sdagsimcnxskeowytrew" "egectidoqkmvjfsdfghj" "sdagsimcnxskeowdasdw"
;"egectidoqkmvjfsdasdw" "sxxxkoaicsioaskgbbcf" "darknightselfasdfdfk" "ssssssssssssssssssss"))
;Output:
;'("alar" "base" "bases" "black" "boar" "board" "boarder" "coco" "dark" "dons"
;"drag" "drags" "dust" "dusts" "fore" "gash" "grim" "joes" "knight" "knights"
;"lack" "lest" "levi" "levis" "monk" "nigh" "night" "nights" "ohio" "olaf"
;"prep" "rags" "reid" "rows" "sags" "self" "togo")
;Time taken:
;23.5 seconds
;
;Input:
;(find-words 5 5 '("catss" "dogst" "flogo" "zlzpp" "fling"))
;Output:
;'("cats" "coop" "dogs" "fling" "flog" "floss" "golf" "logo" "loss" "pots" "stop")
;Time taken:
;~1 second